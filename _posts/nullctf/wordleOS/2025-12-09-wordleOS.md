---
title: "wordleOS"
date: 2025-12-09 12:00:00 +0200
categories: [nullctf, wordleOS]
tags: [reverse, os]
---
## Challenge Information
* **Name:** wordleOS
* **Category:** Reverse Engineering / OS
* **Author:** tomadimitrie
* **Description:**
    > They say you can build an OS for everything, so I built one that can play Wordle.
    > Well, kinda, I am a bit colorblind, so I couldn't put the colored letters. They are all white (I think). But it should tell you when you get the word correct anyway.
    >
    > *Note: Run with `qemu-system-x86_64 -drive format=raw,file=wordle_os.bin`*

---

## 1. Initial Exploration
We start by running the provided disk image in QEMU as instructed:

```bash
qemu-system-x86_64 -drive format=raw,file=wordle_os.bin
```
![Description of image](/assets/img/nullctf/wordleOS/init.png)

We are greeted with a "Welcome to WordleOS!" screen. The game prompts for input, but as the description hints, the visual feedback (colored letters) is missing. Guessing words blindly isn't an option, so we need to analyze the kernel binary to find the win condition.

---

## 2. Extraction
Since this is a raw disk image (.bin), it likely contains a bootloader and a kernel. We search for the kernel by looking for ELF headers (magic bytes `\x7fELF`).

Scanning the file with Python:

```python
import pathlib, re

b = pathlib.Path("wordle_os.bin").read_bytes()
for m in re.finditer(b"\x7fELF", b):
    print("ELF @", m.start())
```
**Output:**
```
ELF @ 21813
ELF @ 22630
ELF @ 52736
```
The ELF at offset 52736 is the valid x86_64 kernel. We extract it using `dd`:

```bash
dd if=wordle_os.bin bs=1 skip=52736 of=kernel status=none
```

---

## 3. Decompilation & Analysis
We load the extracted kernel binary into Ghidra. Looking for DAT variables, we find a large `if` statement comparing memory at address `_DAT_0020a490` against several 64-bit constants.
The code looks like this:

![ ](/assets/img/nullctf/wordleOS/strings.png)

### üß© The Trick: VGA Text Mode & Little Endian
The memory address `0x0020a490` corresponds to the VGA text buffer. In VGA text mode, characters are stored as 2-byte pairs: `[Character] [Attribute]`.

However, because x86_64 is **Little Endian**, the bytes in the 64-bit constants are reversed.

The `0x0f` bytes (seen as `f` or `0f` in the hex constants) serve as the VGA attribute (White on Black) or padding space between the actual data.

The remaining bytes are the valid ASCII characters of the flag.

For example, the constant `0xf200f750f200f6e` (interpreted as 0x0f20...) breaks down in Little Endian as:

| Byte | Meaning |
|------|----------|
| 0x6e | 'n' |
| 0x0f | Attribute |
| 0x20 | ' ' |
| 0x0f | Attribute |
| 0x75 | 'u' |
| 0x0f | Attribute |
| 0x20 | ' ' |
| 0x0f | Attribute |

---

## 4. Decoding the Flag
We extract the constants from the decompiled code. Some constants require simple arithmetic (e.g., `... + 0x33`) which we apply before decoding. We then strip out the 0x0f attribute bytes to reveal the ASCII string.

### Solving is easy by hand, just make it big endian and keeping every two byte.

![ ](/assets/img/nullctf/wordleOS/hextostring.png)


## üèÅ Final Flag

![](/assets/img/nullctf/wordleOS/flagcheck.png)

```
null{b00t_1nt0_w0rdl3}
```
